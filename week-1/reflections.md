# 1.1 Think About Time Reflection
After skimming through the links given, I focused on Focused Attention Meditation, the first technique mentioned. I chose this partly because it was the most basic one abstractly, and partly because it seemed the most accessible to me out of all the techniques I looked at. The fact that a distraction often helps you solve the problem quickly when you look with fresh eyes, combined with the stress relief benefits and accessibility of the technique, it appealed to me the most. 

Time boxing is the practice of applying varying set time limits to accomplish tasks in, and thus learning how to break large projects into smaller chunks. Speed dating is one technique that utilizes 7 minute windows to accomplish small tasks, followed by review, while the Pomodoro technique uses 25 minute windows followed by 5 minute breaks. I could definitely use it in Phase 0, I think it would help me to break the larger problems down into chunks and make sure that I'm methodic in my process.

Right now I usually write a physical to-do list with as many boxes as I can, which helps to break big projects down into pieces. I've also read about the positive effects of physically making the check after completing a task, so I do this and specifically make as many tasks to check off that I can.

It works fairly well when I utilize it, I'm usually very productive when I use it and follow it rigorously. The only times it isn't effective is when I don't follow it closely or take it seriously while making the list. That said, I've never much experimented with other concepts so it might not be the best one. 

I think I will try meditation and time boxing in order to manage my time very effectively. A big potential issue for me is wasting too much time when I'm stuck and should just be moving on, and this would help me to cut myself off before I waste too much time. I think utilizing this method in conjunction with FAM meditation will be a very effective way to manage my wellbeing while I'm doing the work, and improving my productivity. 

# 1.2 The Command Line Reflection
1. A shell is the interface we use to interact with the computer. As far as I have been able to figure out, GUI interfaces like Windows are a shell just like CLIs like Terminal/Command Prompt are. Bash is the individual shell that we're using to control the computer through the terminal.

2. The most challenging part was mastering how pipes and redirections work, as I still don't have a 100% grasp on the syntax for those pieces (for example, which side the file vs command goes on when using < vs >. I'm also unclear about env commands and their use, although I saw on Slack that it's something that will mainly come up later on. I also felt confused about grep after finishing the crash course, although I was able to find more sufficient information about that on the internet. 

3. I was able to successfully use all of the commands, although I had some issues redirecting cat commands into other files, and I said before I'm not entirely sure what env commands are used for, so I didn't play around with those too much. 

4. I think that cat, mkdir, touch, and other creation and reading commands are probably most useful for command line scripting. Navigating the command line itself relies very heavily on cd, ls, pwd, pushd, popd, and less. 

5. pwd - print current working directory

ls - list contents of the current directory, other flags can be used to show the whole tree

mv - move a file from where it is to the directory you designate

cd - change directory you're in

../ - the directory in the stack above the current directory

touch - create an empty file

mkdir- create an empty folder

less - read a text document in a separate session (right?), where space will neatly page-down the document one screen at a time and W will bring you back up. It also won't pull you to the end of the document in the event of long documents.

rmdir - remove an empty folder

rm - remove a file

help - in Linux we use the man command instead of help but this gives you the included manual on a command. very in-depth. 

# 1.4 Forking and Cloning Reflection
1. The instructions provided, through both the step-by-step and video instructions, are pretty much perfect in my eyes. 

a. Start by explaining what a repository is (basically a folder, but it lives on the cloud), and show how to make a new repository on GitHub's site.

b. Next, show how to fork other people's repositories to your own GitHub account and explain why that's valuable (see below).

c. Lastly, show how to clone the remote repository from your GitHub account to your local machine using the terminal.

Forking a repository is basically useful as a means of copying an entire file/folder, and all of its contents, to your own account quickly and easily with one button, rather than creating a new repository and then individually copying all of the contents over one at a time. Aside from time-saving, it also helps ensure that you don't accidentally miss some file buried deep in the repository. 

2. I tend to get confused on every step that includes using a new peripheral application from the terminal, since most of the explanatory steps have links to other pages that are teaching initial setup. However, a lot of these pages are setup guides of their own, written by individual coders, not organizations with an educational agenda, so they have lots of personal recommendations that occasionally conflict with each other (use vim vs sublime, use homebrew or don't use homebrew, etc). I'll end up reading a few of the side materials, getting confused and spending an hour researching, but then when I throw up my hands and just move on through the course material I realize that I should've ignored the majority of those side readings and just stuck with the DBC-created instructions and videos.

I also got hung up a bit on the part where the instructions talk about HTML vs SSH for cloning the repository to my local machine, and only after reading a bit online did I realize that at least for where I'm at, it doesn't really make a difference. Part of me wishes that it wasn't mentioned at all, since GitHub defaults with HTML and we're set up to use HTML in the computer setup process, since it just sent me down a rabbit hole, but I've also never complained about learning something, even something that's not immediately helpful, so I'm hesitant to forcefully stand behind that. 